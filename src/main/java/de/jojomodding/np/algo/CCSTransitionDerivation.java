package de.jojomodding.np.algo;

import de.jojomodding.np.ccs.expr.Binding;
import de.jojomodding.np.ccs.expr.CCSExpression;
import de.jojomodding.np.ccs.expr.Variable;
import de.jojomodding.np.lts.Action;
import de.jojomodding.np.lts.LTS;
import de.jojomodding.np.util.Pair;
import de.jojomodding.np.util.Utils;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Derives LTSs from CCS bindings
 */
public class CCSTransitionDerivation {

    private final Binding binding;
    private final Map<String, Set<Pair<Action, CCSExpression>>> derivations;
    private final Map<CCSExpression, Set<Pair<Action, CCSExpression>>> cachedDerivations;

    /**
     * Constructs a new deriver that derives expressions in a given context
     * @param b the context
     */
    public CCSTransitionDerivation(Binding b) {
        this.binding = b;
        this.derivations = new HashMap<>();
        this.cachedDerivations = new HashMap<>();
    }

    /**
     * Derives the action-sucessor-pairs for a single expression
     * @param expr the expression
     * @return the derived transitions
     */
    public Set<Pair<Action, CCSExpression>> derive(CCSExpression expr) {
        if (!cachedDerivations.containsKey(expr)) {
            deriveInternal(expr);
        }
        return cachedDerivations.get(expr);
    }

    private void deriveInternal(CCSExpression base) {
        Set<String> targetVariables = new HashSet<>(base.usedVariables());
        int card;
        do {
            card = targetVariables.size();
            targetVariables.addAll(targetVariables.stream().flatMap(s -> binding.lookup(s).map(CCSExpression::usedVariables).orElse(Set.of()).stream()).collect(Collectors.toSet()));
        } while (card < targetVariables.size());
        targetVariables.removeIf(derivations::containsKey);
        Map<String, Set<Pair<Action, CCSExpression>>> partialDerivations = new HashMap<>(), oldPDs, pdf1 = partialDerivations;
        targetVariables.forEach(e -> pdf1.put(e, new HashSet<>()));

        do {
            oldPDs = partialDerivations;
            partialDerivations = new HashMap<>();
            for (String var : targetVariables) {
                partialDerivations.put(var, binding.lookup(var).orElseGet(() -> new Variable(var)).deriveTransitions(
                        Utils.fallingBackTo(
                                Set.of(),
                                Utils.asPartialFunction(derivations),
                                Utils.asPartialFunction(oldPDs)
                        )
                ));
            }
        } while (!partialDerivations.equals(oldPDs));
        partialDerivations.forEach(derivations::put);
        partialDerivations.forEach((k, v) -> cachedDerivations.put(new Variable(k), v));
        cachedDerivations.put(base, base.deriveTransitions(e -> derivations.getOrDefault(e, Set.of())));
    }

    /**
     * Given an expressions, derives all transitions in the reachable fragment
     * @param base the expression from where to start deriving
     * @return the reachable fragment
     */
    public Set<Pair<CCSExpression, Pair<Action, CCSExpression>>> deriveAllReachable(CCSExpression base) {
        Set<CCSExpression> reachableFragment = new HashSet<>(), oldReachableFragment;
        reachableFragment.add(base);
        do {
            oldReachableFragment = new HashSet<>(reachableFragment);
            oldReachableFragment.stream().flatMap(p -> derive(p).stream().map(Pair::second)).forEach(reachableFragment::add);
        } while (reachableFragment.size() != oldReachableFragment.size());
        return reachableFragment.stream().flatMap(p -> derive(p).stream().map(v -> new Pair<>(p, v))).collect(Collectors.toSet());
    }

    /**
     * Derives the minimal LTS isomorphic to the canonical LTS represented by a given expression in the context
     * @param base the expression
     * @return the LTS generated by the expression
     */
    public LTS<CCSExpression> getReachableLTS(CCSExpression base) {
        return new LTS<>(deriveAllReachable(base), base);
    }


}
